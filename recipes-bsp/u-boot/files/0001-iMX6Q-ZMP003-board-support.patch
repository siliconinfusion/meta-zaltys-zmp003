diff --git a/arch/arm/cpu/armv7/mx6/Kconfig b/arch/arm/cpu/armv7/mx6/Kconfig
index 1bcd399..3586a87 100644
--- a/arch/arm/cpu/armv7/mx6/Kconfig
+++ b/arch/arm/cpu/armv7/mx6/Kconfig
@@ -92,6 +92,12 @@ config TARGET_MX6QSABREAUTO
 	select DM
 	select DM_THERMAL
 
+config TARGET_MX6QZMP003
+	bool "mx6qzmp003"
+	select SUPPORT_SPL
+	select DM
+	select DM_THERMAL
+
 config TARGET_MX6SABRESD
 	bool "mx6sabresd"
 	select SUPPORT_SPL
@@ -191,6 +197,7 @@ source "board/congatec/cgtqmx6eval/Kconfig"
 source "board/embest/mx6boards/Kconfig"
 source "board/freescale/mx6qarm2/Kconfig"
 source "board/freescale/mx6qsabreauto/Kconfig"
+source "board/freescale/mx6qzmp003/Kconfig"
 source "board/freescale/mx6sabresd/Kconfig"
 source "board/freescale/mx6slevk/Kconfig"
 source "board/freescale/mx6sxsabresd/Kconfig"
diff --git a/board/freescale/mx6qzmp003/Kconfig b/board/freescale/mx6qzmp003/Kconfig
new file mode 100644
index 0000000..86b4db3
--- /dev/null
+++ b/board/freescale/mx6qzmp003/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_MX6QZMP003
+
+config SYS_BOARD
+	default "mx6qzmp003"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_CONFIG_NAME
+	default "mx6qzmp003"
+
+endif
diff --git a/board/freescale/mx6qzmp003/Makefile b/board/freescale/mx6qzmp003/Makefile
new file mode 100644
index 0000000..de2890b
--- /dev/null
+++ b/board/freescale/mx6qzmp003/Makefile
@@ -0,0 +1,10 @@
+#
+# Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+#
+# (C) Copyright 2011 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6qzmp003.o
+
diff --git a/board/freescale/mx6qzmp003/mx6qzmp003.c b/board/freescale/mx6qzmp003/mx6qzmp003.c
new file mode 100644
index 0000000..6405ec1
--- /dev/null
+++ b/board/freescale/mx6qzmp003/mx6qzmp003.c
@@ -0,0 +1,1137 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Author: Fabio Estevam <fabio.estevam@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/video.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <miiphy.h>
+#include <netdev.h>
+
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/crm_regs.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#ifdef CONFIG_CMD_SATA
+#include <asm/imx-common/sata.h>
+#endif
+#ifdef CONFIG_FASTBOOT
+#include <fastboot.h>
+#endif /*CONFIG_FASTBOOT*/
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED | \
+		      PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#ifdef CONFIG_SYS_I2C_MXC
+/* I2C2 Camera, MIPI, pfuze */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_EIM_EB2__I2C2_SCL    | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6_PAD_EIM_EB2__GPIO2_IO30 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(2, 30)
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_EIM_D16__I2C2_SDA    | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6_PAD_EIM_D16__GPIO3_IO16 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(3, 16)
+	}
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = ((ulong)CONFIG_DDR_MB * 1024 * 1024);
+
+	return 0;
+}
+
+/* Select the UART pins to be used for the console */
+#if (CONFIG_MXC_UART_BASE == UART1_BASE)
+iomux_v3_cfg_t const uart_pads[] = {
+	MX6_PAD_CSI0_DAT10__UART1_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSI0_DAT11__UART1_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+#elif (CONFIG_MXC_UART_BASE == UART4_BASE)
+iomux_v3_cfg_t const uart_pads[] = {
+	MX6_PAD_CSI0_DAT12__UART4_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSI0_DAT13__UART4_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSI0_DAT16__UART4_RTS_B   | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSI0_DAT17__UART4_CTS_B   | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+#elif (CONFIG_MXC_UART_BASE == UART5_BASE)
+iomux_v3_cfg_t const uart_pads[] = {
+	MX6_PAD_CSI0_DAT14__UART5_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSI0_DAT15__UART5_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSI0_DAT18__UART5_RTS_B   | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSI0_DAT19__UART5_CTS_B   | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+#else
+#error "Unsupported console UART selected"
+#endif
+
+iomux_v3_cfg_t const enet_pads[] = {
+	MX6_PAD_ENET_MDIO__ENET_MDIO		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_MDC__ENET_MDC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TXC__RGMII_TXC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD0__RGMII_TD0		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD1__RGMII_TD1		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD2__RGMII_TD2		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD3__RGMII_TD3		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TX_CTL__RGMII_TX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_REF_CLK__ENET_TX_CLK	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RXC__RGMII_RXC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD0__RGMII_RD0		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD1__RGMII_RD1		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD2__RGMII_RD2		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD3__RGMII_RD3		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	/* PHY Reset */
+	MX6_PAD_ENET_CRS_DV__GPIO1_IO25		| MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_enet(void)
+{
+	imx_iomux_v3_setup_multiple_pads(enet_pads, ARRAY_SIZE(enet_pads));
+
+	/* Reset PHY */
+	gpio_direction_output(IMX_GPIO_NR(1, 25) , 0);
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(1, 25), 1);
+	udelay(100);
+}
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6_PAD_SD3_CLK__SD3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_CMD__SD3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_RST__GPIO7_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL), /* CD */
+};
+
+static iomux_v3_cfg_t const usdhc4_pads[] = {
+	MX6_PAD_SD4_CLK__SD4_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_CMD__SD4_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT0__SD4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT1__SD4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT2__SD4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT3__SD4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT4__SD4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT5__SD4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT6__SD4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT7__SD4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_ALE__SD4_RESET | MUX_PAD_CTRL(NO_PAD_CTRL), /* RESET */
+};
+
+static iomux_v3_cfg_t const pcie_pads[] = {
+	MX6_PAD_NANDF_CS0__GPIO6_IO11 | MUX_PAD_CTRL(NO_PAD_CTRL), /* PERST */
+	MX6_PAD_NANDF_CS1__GPIO6_IO14 | MUX_PAD_CTRL(NO_PAD_CTRL), /* RSTHALT */
+};
+
+static iomux_v3_cfg_t const onboard_fpga_pads[] = {
+	MX6_PAD_EIM_A24__GPIO5_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),  /* PROGB */
+	MX6_PAD_SD3_DAT6__GPIO6_IO18 | MUX_PAD_CTRL(NO_PAD_CTRL), /* CSN */
+	MX6_PAD_EIM_D21__GPIO3_IO21 | MUX_PAD_CTRL(NO_PAD_CTRL),  /* MODE1 */
+};
+
+static iomux_v3_cfg_t const onboard_gps_pads[] = {
+        MX6_PAD_EIM_EB3__GPIO2_IO31 | MUX_PAD_CTRL(NO_PAD_CTRL),  /* RSTn */
+        MX6_PAD_EIM_D26__GPIO3_IO26 | MUX_PAD_CTRL(NO_PAD_CTRL),  /* ONOFF */
+        MX6_PAD_EIM_D23__GPIO3_IO23 | MUX_PAD_CTRL(NO_PAD_CTRL),  /* OUT1 */
+        MX6_PAD_EIM_D24__GPIO3_IO24 | MUX_PAD_CTRL(NO_PAD_CTRL),  /* OUT2 */
+};
+
+static iomux_v3_cfg_t const clc_cpu_sys_pads[] = {
+        /* Temporarily set them up as GPIO for board testing purposes */
+        MX6_PAD_NANDF_CLE__GPIO6_IO07  | MUX_PAD_CTRL(NO_PAD_CTRL), /* int0 */
+        MX6_PAD_NANDF_WP_B__GPIO6_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL), /* int1 */
+};
+
+static void setup_pcie(void)
+{
+	imx_iomux_v3_setup_multiple_pads(pcie_pads, ARRAY_SIZE(pcie_pads));
+}
+
+#define GPIO_C3FPGA_PROGB	IMX_GPIO_NR(5, 4)
+#define GPIO_C3FPGA_CSN		IMX_GPIO_NR(6, 18)
+#define GPIO_C3FPGA_MODE1	IMX_GPIO_NR(3, 21)
+
+/* Places FPGA in reset and selects SPI master mode flash programming */
+static void setup_iomux_fpga(void)
+{
+	imx_iomux_v3_setup_multiple_pads(onboard_fpga_pads, ARRAY_SIZE(onboard_fpga_pads));	
+	gpio_direction_output(GPIO_C3FPGA_PROGB, 0);
+	gpio_direction_output(GPIO_C3FPGA_CSN, 1);
+	gpio_direction_output(GPIO_C3FPGA_MODE1, 0);
+}
+
+/* Releases FPGA reset and initates SPI flash programming */
+/* TODO: Should wait for programming completion - requires board mod */
+static void setup_program_fpga(void)
+{
+	udelay (2);
+	gpio_set_value(GPIO_C3FPGA_PROGB, 1);
+	printf ("Programming onboard FPGA (not waiting for DONE)\n");	
+	udelay (2);	
+}
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart_pads, ARRAY_SIZE(uart_pads));
+}
+
+#define GPIO_GPS_RSTn  IMX_GPIO_NR(2, 31)
+#define GPIO_GPS_ONOFF IMX_GPIO_NR(3, 26)
+#define GPIO_GPS_OUT1  IMX_GPIO_NR(3, 23)
+#define GPIO_GPS_OUT2  IMX_GPIO_NR(3, 24)
+
+static void setup_iomux_gps(void)
+{
+        imx_iomux_v3_setup_multiple_pads(onboard_gps_pads, ARRAY_SIZE(onboard_gps_pads));	
+	gpio_direction_output(GPIO_GPS_RSTn,  1);
+	gpio_direction_output(GPIO_GPS_ONOFF, 0);
+}
+
+static void setup_iomux_clc(void)
+{
+        imx_iomux_v3_setup_multiple_pads(clc_cpu_sys_pads, ARRAY_SIZE(clc_cpu_sys_pads));	
+}
+
+static void setup_standby_mode(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+        int reg;
+
+        /* Do not assert PMIC_STBY_REQ pin in iMX STOP mode */
+        reg = readl(&mxc_ccm->clpcr);
+        reg &= ~MXC_CCM_CLPCR_VSTBY;
+        writel(reg, &mxc_ccm->clpcr);
+}
+
+#ifdef CONFIG_SYS_I2C_MXC
+
+/* set all switches APS in normal and PFM mode in standby */
+static int setup_pmic_mode(int chip)
+{
+	unsigned char offset, i, switch_num, value;
+
+	if (!chip) {
+		/* pfuze100 */
+		switch_num = 6;
+		offset = 0x31;
+	} else {
+		/* pfuze200 */
+		switch_num = 4;
+		offset = 0x38;
+	}
+
+	value = 0xc;
+	if (i2c_write(0x8, 0x23, 1, &value, 1)) {
+		printf("Set SW1AB mode error!\n");
+		return -1;
+	}
+
+	for (i = 0; i < switch_num - 1; i++) {
+		if (i2c_write(0x8, offset + i * 7, 1, &value, 1)) {
+			printf("Set switch%x mode error!\n", offset);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int setup_pmic_voltages(void)
+{
+	unsigned char value, rev_id = 0 ;
+
+	i2c_set_bus_num(1);
+	if (!i2c_probe(0x8)) {
+		if (i2c_read(0x8, 0, 1, &value, 1)) {
+			printf("Read device ID error!\n");
+			return -1;
+		}
+		if (i2c_read(0x8, 3, 1, &rev_id, 1)) {
+			printf("Read Rev ID error!\n");
+			return -1;
+		}
+		printf("Found PFUZE%s deviceid=%x,revid=%x\n",
+			((value & 0xf) == 0) ? "100" : "200", value, rev_id);
+
+		if (setup_pmic_mode(value & 0xf)) {
+			printf("setup pmic mode error!\n");
+			return -1;
+		}
+		/*For camera streaks issue,swap VGEN5 and VGEN3 to power camera.
+		*sperate VDDHIGH_IN and camera 2.8V power supply, after switch:
+		*VGEN5 for VDDHIGH_IN and increase to 3V to align with datasheet
+		*VGEN3 for camera 2.8V power supply
+		*/
+		/*increase VGEN3 from 2.5 to 2.8V*/
+		if (i2c_read(0x8, 0x6e, 1, &value, 1)) {
+			printf("Read VGEN3 error!\n");
+			return -1;
+		}
+		value &= ~0xf;
+		value |= 0xa;
+		if (i2c_write(0x8, 0x6e, 1, &value, 1)) {
+			printf("Set VGEN3 error!\n");
+			return -1;
+		}
+		/*increase VGEN5 from 2.8 to 3V*/
+		if (i2c_read(0x8, 0x70, 1, &value, 1)) {
+			printf("Read VGEN5 error!\n");
+			return -1;
+		}
+		value &= ~0xf;
+		value |= 0xc;
+		if (i2c_write(0x8, 0x70, 1, &value, 1)) {
+			printf("Set VGEN5 error!\n");
+			return -1;
+		}
+		/* set SW1AB staby volatage 0.975V*/
+		if (i2c_read(0x8, 0x21, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= 0x1b;
+		if (i2c_write(0x8, 0x21, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		if (i2c_read(0x8, 0x24, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(0x8, 0x24, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C staby volatage 0.975V*/
+		if (i2c_read(0x8, 0x2f, 1, &value, 1)) {
+			printf("Read SW1CSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= 0x1b;
+		if (i2c_write(0x8, 0x2f, 1, &value, 1)) {
+			printf("Set SW1CSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		if (i2c_read(0x8, 0x32, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(0x8, 0x32, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+
+                /* enable LICELL pin (battery charger output), set to 3.1v */
+                value = 0x0D;
+		if (i2c_write(0x8, 0x1A, 1, &value, 1)) {
+			printf("Set COINCTL error!\n");
+			return -1;
+                }
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned char value;
+	int is_400M;
+	unsigned char vddarm;
+
+	/* increase VDDARM/VDDSOC to support 1.2G chip */
+	if (check_1_2G()) {
+		ldo_bypass = 0;	/* ldo_enable on 1.2G chip */
+		printf("1.2G chip, increase VDDARM_IN/VDDSOC_IN\n");
+		/* increase VDDARM to 1.425V */
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x2d;
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* increase VDDSOC to 1.425V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x2d;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+	}
+	/* switch to ldo_bypass mode , boot on 800Mhz */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+
+		/* decrease VDDARM for 400Mhz DQ:1.1V, DL:1.275V */
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x20;
+		
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* increase VDDSOC to 1.3V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x28;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		/*
+		 * MX6Q:
+		 * VDDARM:1.15V@800M; VDDSOC:1.175V@800M
+		 * VDDARM:0.975V@400M; VDDSOC:1.175V@400M
+		 */
+		is_400M = set_anatop_bypass(2);
+		if (is_400M)
+			vddarm = 0x1b;
+		else
+			vddarm = 0x22;
+		
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= vddarm;
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+
+		/* decrease VDDSOC to 1.175V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x23;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC3_BASE_ADDR},
+	{USDHC4_BASE_ADDR},
+};
+
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(7, 8)
+
+int board_mmc_get_env_dev(int devno)
+{
+	return devno - 2;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	case USDHC4_BASE_ADDR:
+		ret = 1; /* eMMC/uSDHC4 is always present */
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+#ifndef CONFIG_SPL_BUILD
+	int ret;
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    SD3
+	 * mmc1                    eMMC
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+			       "(%d) then supported by the board (%d)\n",
+			       i + 1, CONFIG_SYS_FSL_USDHC_NUM);
+			return -EINVAL;
+		}
+
+		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+#else
+	struct src *psrc = (struct src *)SRC_BASE_ADDR;
+	unsigned reg = readl(&psrc->sbmr1) >> 11;
+	/*
+	 * Upon reading BOOT_CFG register the following map is done:
+	 * Bit 11 and 12 of BOOT_CFG register can determine the current
+	 * mmc port
+	 * 0x2                  SD3
+	 * 0x3                  SD4
+	 */
+
+	switch (reg & 0x3) {
+	case 0x2:
+		imx_iomux_v3_setup_multiple_pads(
+			usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+		usdhc_cfg[0].esdhc_base = USDHC3_BASE_ADDR;
+		usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+		gd->arch.sdhc_clk = usdhc_cfg[0].sdhc_clk;
+		break;
+	case 0x3:
+		imx_iomux_v3_setup_multiple_pads(
+			usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+		usdhc_cfg[0].esdhc_base = USDHC4_BASE_ADDR;
+		usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+		gd->arch.sdhc_clk = usdhc_cfg[0].sdhc_clk;
+		break;
+	}
+
+	return fsl_esdhc_initialize(bis, &usdhc_cfg[0]);
+#endif
+}
+#endif
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+#if defined(CONFIG_VIDEO_IPUV3)
+iomux_v3_cfg_t const video_io_pads[] = {
+	MX6_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK | MUX_PAD_CTRL(NO_PAD_CTRL), /* DISP0_CLK */
+	MX6_PAD_DI0_PIN15__IPU1_DI0_PIN15 | MUX_PAD_CTRL(NO_PAD_CTRL),       /* DISP0_DRDY */
+	MX6_PAD_DI0_PIN2__IPU1_DI0_PIN02 | MUX_PAD_CTRL(NO_PAD_CTRL),        /* DISP0_HSYNC */
+	MX6_PAD_DI0_PIN3__IPU1_DI0_PIN03 | MUX_PAD_CTRL(NO_PAD_CTRL),        /* DISP0_VSYNC */
+	MX6_PAD_KEY_COL3__HDMI_TX_DDC_SCL | MUX_PAD_CTRL(I2C_PAD_CTRL),      /* HDMI I2C SCL */
+	MX6_PAD_KEY_ROW3__HDMI_TX_DDC_SDA | MUX_PAD_CTRL(I2C_PAD_CTRL),      /* HDMI I2C SDA */
+	MX6_PAD_EIM_A25__HDMI_TX_CEC_LINE | MUX_PAD_CTRL(NO_PAD_CTRL),       /* HDMI CEC */
+};
+
+static iomux_v3_cfg_t const rgb_pads[] = {
+	MX6_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DI0_PIN15__IPU1_DI0_PIN15 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DI0_PIN2__IPU1_DI0_PIN02 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DI0_PIN3__IPU1_DI0_PIN03 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DI0_PIN4__IPU1_DI0_PIN04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT0__IPU1_DISP0_DATA00 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT1__IPU1_DISP0_DATA01 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT2__IPU1_DISP0_DATA02 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT3__IPU1_DISP0_DATA03 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT4__IPU1_DISP0_DATA04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT5__IPU1_DISP0_DATA05 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT6__IPU1_DISP0_DATA06 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT7__IPU1_DISP0_DATA07 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT8__IPU1_DISP0_DATA08 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT9__IPU1_DISP0_DATA09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT10__IPU1_DISP0_DATA10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT11__IPU1_DISP0_DATA11 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT12__IPU1_DISP0_DATA12 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT13__IPU1_DISP0_DATA13 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT14__IPU1_DISP0_DATA14 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT15__IPU1_DISP0_DATA15 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT16__IPU1_DISP0_DATA16 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT17__IPU1_DISP0_DATA17 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT18__IPU1_DISP0_DATA18 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT19__IPU1_DISP0_DATA19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT20__IPU1_DISP0_DATA20 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT21__IPU1_DISP0_DATA21 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT22__IPU1_DISP0_DATA22 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_DISP0_DAT23__IPU1_DISP0_DATA23 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO_6__GPIO1_IO06 | MUX_PAD_CTRL(NO_PAD_CTRL), /* DISP0 ON */
+};
+
+static void disable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	int reg = readl(&iomux->gpr[2]);
+
+	reg &= ~(IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+		 IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
+
+	writel(reg, &iomux->gpr[2]);
+}
+
+static void do_enable_rgb(struct display_info_t const *dev)
+{
+	disable_lvds(dev);
+	imx_iomux_v3_setup_multiple_pads(rgb_pads, ARRAY_SIZE(rgb_pads));
+	gpio_direction_output(IMX_GPIO_NR(1, 6), 1);
+}
+
+static void do_enable_hdmi(struct display_info_t const *dev)
+{
+	disable_lvds(dev);
+	imx_enable_hdmi_phy();
+}
+
+struct display_info_t const displays[] = {
+  {
+	.bus	= 0,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= NULL,
+	.enable	= do_enable_rgb,
+	.mode	= {
+		.name           = "LCD-WVGA",
+		.refresh        = 60,
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 32100,
+		.left_margin    = 40,
+		.right_margin   = 88,
+		.upper_margin   = 13,
+		.lower_margin   = 32,
+		.hsync_len      = 48,
+		.vsync_len      = 3,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED }
+  }, 
+  {
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= detect_hdmi,
+	.enable	= do_enable_hdmi,
+	.mode	= {
+		.name           = "HDMI",
+		.refresh        = 60,
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED }
+  },
+};
+size_t display_count = ARRAY_SIZE(displays);
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int reg;
+
+	/* Setup default video I/O pads, including sync lines for debugging */
+	imx_iomux_v3_setup_multiple_pads(video_io_pads, ARRAY_SIZE(video_io_pads));
+
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	/* Turn on LDB0, LDB1, IPU,IPU DI0 clocks */
+	reg = readl(&mxc_ccm->CCGR3);
+	reg |=  MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
+	writel(reg, &mxc_ccm->CCGR3);
+
+	/* set LDB0, LDB1 clk select to 011/011 */
+	reg = readl(&mxc_ccm->cs2cdr);
+	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
+		 | MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
+	      | (3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->cs2cdr);
+
+	reg = readl(&mxc_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+	writel(reg, &mxc_ccm->cscmr2);
+
+	reg = readl(&mxc_ccm->chsccdr);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->chsccdr);
+
+	reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
+	     | IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT
+	     | IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
+	     | IOMUXC_GPR2_LVDS_CH0_MODE_DISABLED
+	     | IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI0;
+	writel(reg, &iomux->gpr[2]);
+
+	reg = readl(&iomux->gpr[3]);
+	reg = (reg & ~(IOMUXC_GPR3_LVDS1_MUX_CTL_MASK
+			| IOMUXC_GPR3_HDMI_MUX_CTL_MASK))
+	    | (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
+	       << IOMUXC_GPR3_LVDS1_MUX_CTL_OFFSET);
+	writel(reg, &iomux->gpr[3]);
+}
+#endif /* CONFIG_VIDEO_IPUV3 */
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	setup_iomux_enet();
+	setup_pcie();
+
+	return cpu_eth_init(bis);
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+static iomux_v3_cfg_t const usb_otg_pads[] = {
+	MX6_PAD_EIM_D22__USB_OTG_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usb_hc1_pads[] = {
+	MX6_PAD_ENET_TXD1__GPIO1_IO29 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+					 ARRAY_SIZE(usb_otg_pads));
+
+	/*
+	 * set daisy chain for otg_pin_id on 6q.
+	 * for 6dl, this bit is reserved
+	 */
+	imx_iomux_set_gpr_register(1, 13, 1, 0);
+
+	imx_iomux_v3_setup_multiple_pads(usb_hc1_pads,
+					 ARRAY_SIZE(usb_hc1_pads));
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	switch (port) {
+	case 0:
+		break;
+	case 1:
+		if (on)
+			gpio_direction_output(IMX_GPIO_NR(1, 29), 1);
+		else
+			gpio_direction_output(IMX_GPIO_NR(1, 29), 0);
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+	setup_iomux_fpga();
+        setup_iomux_gps();
+        setup_iomux_clc();
+	
+        setup_standby_mode();
+
+#if defined(CONFIG_VIDEO_IPUV3)
+	setup_display();
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_CMD_SATA
+	setup_sata();
+#endif
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+	setup_epdc();
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd3",	 MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	/* 8 bit bus width */
+	{"emmc", MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+	int ret = 0;
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	ret = setup_pmic_voltages();
+	if (ret)
+		return -1;
+#endif
+
+	setup_program_fpga();
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: Zaltys ZMP003\n");
+	return 0;
+}
+
+
+#ifdef CONFIG_SPL_BUILD
+#include <spl.h>
+#include <libfdt.h>
+
+const struct mx6dq_iomux_ddr_regs mx6_ddr_ioregs = {
+	.dram_sdclk_0 =  0x00020030,
+	.dram_sdclk_1 =  0x00020030,
+	.dram_cas =  0x00020030,
+	.dram_ras =  0x00020030,
+	.dram_reset =  0x00020030,
+	.dram_sdcke0 =  0x00003000,
+	.dram_sdcke1 =  0x00003000,
+	.dram_sdba2 =  0x00000000,
+	.dram_sdodt0 =  0x00003030,
+	.dram_sdodt1 =  0x00003030,
+	.dram_sdqs0 =  0x00000030,
+	.dram_sdqs1 =  0x00000030,
+	.dram_sdqs2 =  0x00000030,
+	.dram_sdqs3 =  0x00000030,
+	.dram_sdqs4 =  0x00000030,
+	.dram_sdqs5 =  0x00000030,
+	.dram_sdqs6 =  0x00000030,
+	.dram_sdqs7 =  0x00000030,
+	.dram_dqm0 =  0x00020030,
+	.dram_dqm1 =  0x00020030,
+	.dram_dqm2 =  0x00020030,
+	.dram_dqm3 =  0x00020030,
+	.dram_dqm4 =  0x00020030,
+	.dram_dqm5 =  0x00020030,
+	.dram_dqm6 =  0x00020030,
+	.dram_dqm7 =  0x00020030,
+};
+
+const struct mx6dq_iomux_ddr_regs mx6dqp_ddr_ioregs = {
+	.dram_sdclk_0 =  0x00000030,
+	.dram_sdclk_1 =  0x00000030,
+	.dram_cas =  0x00000030,
+	.dram_ras =  0x00000030,
+	.dram_reset =  0x00000030,
+	.dram_sdcke0 =  0x00003000,
+	.dram_sdcke1 =  0x00003000,
+	.dram_sdba2 =  0x00000000,
+	.dram_sdodt0 =  0x00003030,
+	.dram_sdodt1 =  0x00003030,
+	.dram_sdqs0 =  0x00000030,
+	.dram_sdqs1 =  0x00000030,
+	.dram_sdqs2 =  0x00000030,
+	.dram_sdqs3 =  0x00000030,
+	.dram_sdqs4 =  0x00000030,
+	.dram_sdqs5 =  0x00000030,
+	.dram_sdqs6 =  0x00000030,
+	.dram_sdqs7 =  0x00000030,
+	.dram_dqm0 =  0x00000030,
+	.dram_dqm1 =  0x00000030,
+	.dram_dqm2 =  0x00000030,
+	.dram_dqm3 =  0x00000030,
+	.dram_dqm4 =  0x00000030,
+	.dram_dqm5 =  0x00000030,
+	.dram_dqm6 =  0x00000030,
+	.dram_dqm7 =  0x00000030,
+};
+
+const struct mx6dq_iomux_grp_regs mx6_grp_ioregs = {
+	.grp_ddr_type =  0x000C0000,
+	.grp_ddrmode_ctl =  0x00020000,
+	.grp_ddrpke =  0x00000000,
+	.grp_addds =  0x00000030,
+	.grp_ctlds =  0x00000030,
+	.grp_ddrmode =  0x00020000,
+	.grp_b0ds =  0x00000030,
+	.grp_b1ds =  0x00000030,
+	.grp_b2ds =  0x00000030,
+	.grp_b3ds =  0x00000030,
+	.grp_b4ds =  0x00000030,
+	.grp_b5ds =  0x00000030,
+	.grp_b6ds =  0x00000030,
+	.grp_b7ds =  0x00000030,
+};
+
+const struct mx6_mmdc_calibration mx6_mmcd_calib = {
+	.p0_mpwldectrl0 =  0x001F001F,
+	.p0_mpwldectrl1 =  0x001F001F,
+	.p1_mpwldectrl0 =  0x00440044,
+	.p1_mpwldectrl1 =  0x00440044,
+	.p0_mpdgctrl0 =  0x434B0350,
+	.p0_mpdgctrl1 =  0x034C0359,
+	.p1_mpdgctrl0 =  0x434B0350,
+	.p1_mpdgctrl1 =  0x03650348,
+	.p0_mprddlctl =  0x4436383B,
+	.p1_mprddlctl =  0x39393341,
+	.p0_mpwrdlctl =  0x35373933,
+	.p1_mpwrdlctl =  0x48254A36,
+};
+
+const struct mx6_mmdc_calibration mx6dqp_mmcd_calib = {
+	.p0_mpwldectrl0 =  0x001B001E,
+	.p0_mpwldectrl1 =  0x002E0029,
+	.p1_mpwldectrl0 =  0x001B002A,
+	.p1_mpwldectrl1 =  0x0019002C,
+	.p0_mpdgctrl0 =  0x43240334,
+	.p0_mpdgctrl1 =  0x0324031A,
+	.p1_mpdgctrl0 =  0x43340344,
+	.p1_mpdgctrl1 =  0x03280276,
+	.p0_mprddlctl =  0x44383A3E,
+	.p1_mprddlctl =  0x3C3C3846,
+	.p0_mpwrdlctl =  0x2E303230,
+	.p1_mpwrdlctl =  0x38283E34,
+};
+
+/* MT41K128M16JT-125 */
+static struct mx6_ddr3_cfg mem_ddr = {
+	.mem_speed = 1600,
+	.density = 2,
+	.width = 16,
+	.banks = 8,
+	.rowaddr = 14,
+	.coladdr = 10,
+	.pagesz = 2,
+	.trcd = 1375,
+	.trcmin = 4875,
+	.trasmin = 3500,
+};
+
+static void ccgr_init(void)
+{
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	writel(0x00C03F3F, &ccm->CCGR0);
+	writel(0x0030FC03, &ccm->CCGR1);
+	writel(0x0FFFC000, &ccm->CCGR2);
+	writel(0x3FF00000, &ccm->CCGR3);
+	writel(0x00FFF300, &ccm->CCGR4);
+	writel(0x0F0000C3, &ccm->CCGR5);
+	writel(0x000003FF, &ccm->CCGR6);
+}
+
+static void gpr_init(void)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	/* enable AXI cache for VDOA/VPU/IPU */
+	writel(0xF00000CF, &iomux->gpr[4]);
+	if (is_mx6dqp()) {
+		/* set IPU AXI-id1 Qos=0x1 AXI-id0/2/3 Qos=0x7 */
+		writel(0x007F007F, &iomux->gpr[6]);
+		writel(0x007F007F, &iomux->gpr[7]);
+	} else {
+		/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+		writel(0x007F007F, &iomux->gpr[6]);
+		writel(0x007F007F, &iomux->gpr[7]);
+	}
+}
+
+/*
+ * This section requires the differentiation between iMX6 Sabre boards, but
+ * for now, it will configure only for the mx6q variant.
+ */
+static void spl_dram_init(void)
+{
+	struct mx6_ddr_sysinfo sysinfo = {
+		/* width of data bus:0=16,1=32,2=64 */
+		.dsize = 2,
+		/* config for full 4GB range so that get_mem_size() works */
+		.cs_density = 32, /* 32Gb per CS */
+		/* single chip select */
+		.ncs = 1,
+		.cs1_mirror = 0,
+		.rtt_wr = 1 /*DDR3_RTT_60_OHM*/,	/* RTT_Wr = RZQ/4 */
+		.rtt_nom = 1 /*DDR3_RTT_60_OHM*/,	/* RTT_Nom = RZQ/4 */
+		.walat = 1,	/* Write additional latency */
+		.ralat = 5,	/* Read additional latency */
+		.mif3_mode = 3,	/* Command prediction working mode */
+		.bi_on = 1,	/* Bank interleaving enabled */
+		.sde_to_rst = 0x10,	/* 14 cycles, 200us (JEDEC default) */
+		.rst_to_cke = 0x23,	/* 33 cycles, 500us (JEDEC default) */
+		.ddr_type = DDR_TYPE_DDR3,
+	};
+
+	if (is_mx6dqp()) {
+		mx6dq_dram_iocfg(64, &mx6dqp_ddr_ioregs, &mx6_grp_ioregs);
+		mx6_dram_cfg(&sysinfo, &mx6dqp_mmcd_calib, &mem_ddr);
+	} else {
+		mx6dq_dram_iocfg(64, &mx6_ddr_ioregs, &mx6_grp_ioregs);
+		mx6_dram_cfg(&sysinfo, &mx6_mmcd_calib, &mem_ddr);
+	}
+}
+
+void board_init_f(ulong dummy)
+{
+	/* setup AIPS and disable watchdog */
+	arch_cpu_init();
+
+	ccgr_init();
+	gpr_init();
+
+	/* iomux and setup of i2c */
+	board_early_init_f();
+
+	/* setup GP timer */
+	timer_init();
+
+	/* UART clocks enabled and gd valid - init serial console */
+	preloader_console_init();
+
+	/* DDR initialization */
+	spl_dram_init();
+
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	/* load/boot image from boot device */
+	board_init_r(NULL, 0);
+}
+#endif
diff --git a/board/freescale/mx6qzmp003/mx6qzmp003.cfg b/board/freescale/mx6qzmp003/mx6qzmp003.cfg
new file mode 100644
index 0000000..aa897e9
--- /dev/null
+++ b/board/freescale/mx6qzmp003/mx6qzmp003.cfg
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+DATA 4, 0x020e0798, 0x000C0000
+DATA 4, 0x020e0758, 0x00000000
+DATA 4, 0x020e0588, 0x00000030
+DATA 4, 0x020e0594, 0x00000030
+DATA 4, 0x020e056c, 0x00000030
+DATA 4, 0x020e0578, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e057c, 0x00000030
+DATA 4, 0x020e058c, 0x00000000
+DATA 4, 0x020e059c, 0x00000030
+DATA 4, 0x020e05a0, 0x00000030
+DATA 4, 0x020e078c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e05a8, 0x00000030
+DATA 4, 0x020e05b0, 0x00000030
+DATA 4, 0x020e0524, 0x00000030
+DATA 4, 0x020e051c, 0x00000030
+DATA 4, 0x020e0518, 0x00000030
+DATA 4, 0x020e050c, 0x00000030
+DATA 4, 0x020e05b8, 0x00000030
+DATA 4, 0x020e05c0, 0x00000030
+DATA 4, 0x020e0774, 0x00020000
+DATA 4, 0x020e0784, 0x00000030
+DATA 4, 0x020e0788, 0x00000030
+DATA 4, 0x020e0794, 0x00000030
+DATA 4, 0x020e079c, 0x00000030
+DATA 4, 0x020e07a0, 0x00000030
+DATA 4, 0x020e07a4, 0x00000030
+DATA 4, 0x020e07a8, 0x00000030
+DATA 4, 0x020e0748, 0x00000030
+DATA 4, 0x020e05ac, 0x00000030
+DATA 4, 0x020e05b4, 0x00000030
+DATA 4, 0x020e0528, 0x00000030
+DATA 4, 0x020e0520, 0x00000030
+DATA 4, 0x020e0514, 0x00000030
+DATA 4, 0x020e0510, 0x00000030
+DATA 4, 0x020e05bc, 0x00000030
+DATA 4, 0x020e05c4, 0x00000030
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+DATA 4, 0x021b083c, 0x43270338
+DATA 4, 0x021b0840, 0x03200314
+DATA 4, 0x021b483c, 0x431A032F
+DATA 4, 0x021b4840, 0x03200263
+DATA 4, 0x021b0848, 0x4B434748
+DATA 4, 0x021b4848, 0x4445404C
+DATA 4, 0x021b0850, 0x38444542
+DATA 4, 0x021b4850, 0x4935493A
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x33333333
+DATA 4, 0x021b4828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b48b8, 0x00000800
+DATA 4, 0x021b0004, 0x00020036
+DATA 4, 0x021b0008, 0x09444040
+DATA 4, 0x021b000c, 0x555A7975
+DATA 4, 0x021b0010, 0xFF538F64
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x005A1023
+DATA 4, 0x021b0040, 0x00000027
+DATA 4, 0x021b0000, 0x831A0000
+DATA 4, 0x021b001c, 0x04088032
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x09408030
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b0020, 0x00005800
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b4818, 0x00011117
+DATA 4, 0x021b0004, 0x00025576
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+
+/*
+ * Setup CCM_CCOSR register as follows:
+ *
+ * cko1_en  = 1	   --> CKO1 enabled
+ * cko1_div = 111  --> divide by 8
+ * cko1_sel = 1011 --> ahb_clk_root
+ *
+ * This sets CKO1 at ahb_clk_root/8 = 132/8 = 16.5 MHz
+ */
+DATA 4, 0x020c4060, 0x000000fb
+#endif
diff --git a/configs/mx6qzmp003_defconfig b/configs/mx6qzmp003_defconfig
new file mode 100644
index 0000000..94e10f5
--- /dev/null
+++ b/configs/mx6qzmp003_defconfig
@@ -0,0 +1,17 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6QZMP003=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qzmp003/mx6qzmp003.cfg,MX6Q,DDR_MB=1024"
+CONFIG_BOOTDELAY=3
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_OF_LIBFDT=y
diff --git a/include/configs/mx6qzmp003.h b/include/configs/mx6qzmp003.h
new file mode 100644
index 0000000..0cebdb4
--- /dev/null
+++ b/include/configs/mx6qzmp003.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6Q SabreSD board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6QZMP003_CONFIG_H
+#define __MX6QZMP003_CONFIG_H
+
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_MACH_TYPE		3980
+
+/* Select the UART to be used for the console. Uses UART 4 by default.
+ * Note that in current Linux builds, the serial console login is not
+ * automatically spawned for UART 5, which could be used as a security 
+ * enhancement in the future (see /etc/init.d/rc_mxc.S).
+ */
+#ifndef CONFIG_MXC_UART_BASE
+#define CONFIG_MXC_UART_BASE		UART4_BASE
+#endif
+
+#if (CONFIG_MXC_UART_BASE == UART1_BASE)
+#define CONFIG_CONSOLE_DEV		"ttymxc0"
+#elif (CONFIG_MXC_UART_BASE == UART4_BASE)
+#define CONFIG_CONSOLE_DEV		"ttymxc3"
+#elif (CONFIG_MXC_UART_BASE == UART5_BASE)
+#define CONFIG_CONSOLE_DEV		"ttymxc4"
+#else
+#error "Unsupported console UART selected"
+#endif
+
+/* Select the device to be used for booting. Uses the SD card by default. */
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#ifndef CONFIG_SYS_MMC_ENV_DEV
+#define CONFIG_SYS_MMC_ENV_DEV		0	/* SDHC3 */
+#endif
+
+/* Store environment variables in the U-Boot partition. */
+#define CONFIG_SYS_MMC_ENV_PART   	0       
+
+/* Select the Linux root device to match the U-Boot location. */
+#if (CONFIG_SYS_MMC_ENV_DEV == 0)
+#define CONFIG_MMCROOT	"/dev/mmcblk2p2"
+#elif (CONFIG_SYS_MMC_ENV_DEV == 0)
+#define CONFIG_MMCROOT	"/dev/mmcblk3p2"
+#else
+#error "Unsupported MMC device selected"
+#endif
+
+/*
+ * The core functionality of the Zaltys ZMP003 board is based on the Freescale
+ * reference design, so uses the same common configuration settings.
+ */
+#include "mx6sabre_common.h"
+
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_FASTBOOT
+
+/* Override the choice of Ethernet PHY from the Freescale reference design */
+#undef CONFIG_PHY_ATHEROS
+#undef CONFIG_FEC_MXC_PHYADDR
+
+#define CONFIG_PHY_MICREL
+#define CONFIG_FEC_MXC_PHYADDR 0
+#define CONFIG_PHY_RESET_DELAY 100
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2 /* Enabled USB controller number */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#error "SPI NOR not supported for ZMP003 board" 
+#endif
+
+/*
+ * TODO: Fix for PCIe switch operation. Currently disabled in U-Boot.
+ *
+ * imx6 q/dl/solo pcie would be failed to work properly in kernel, if
+ * the pcie module is iniialized/enumerated both in uboot and linux
+ * kernel.
+ * rootcause:imx6 q/dl/solo pcie don't have the reset mechanism.
+ * it is only be RESET by the POR. So, the pcie module only be
+ * initialized/enumerated once in one POR.
+ * Set to use pcie in kernel defaultly, mask the pcie config here.
+ * Remove the mask freely, if the uboot pcie functions, rather than
+ * the kernel's, are required.
+ */
+/* #define CONFIG_CMD_PCI */
+#ifdef CONFIG_CMD_PCI
+#define CONFIG_PCI
+#define CONFIG_PCI_PNP
+#define CONFIG_PCI_SCAN_SHOW
+#define CONFIG_PCIE_IMX
+#define CONFIG_PCIE_IMX_PERST_GPIO	IMX_GPIO_NR(7, 12)
+#define CONFIG_PCIE_IMX_POWER_GPIO	IMX_GPIO_NR(3, 19)
+#endif
+
+#endif                         /* __MX6QZMP003_CONFIG_H */
diff --git a/include/configs/mx6sabre_common.h b/include/configs/mx6sabre_common.h
index 3d599fb..4a354fc 100644
--- a/include/configs/mx6sabre_common.h
+++ b/include/configs/mx6sabre_common.h
@@ -192,7 +192,7 @@
 
 
 #define CONFIG_BOOTCOMMAND \
-	"run findfdt;" \
+	"setenv fdt_file imx6q-zmp003.dtb;" \
 	"mmc dev ${mmcdev};" \
 	"if mmc rescan; then " \
 		"if run loadbootscript; then " \
